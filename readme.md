<!--+ Warning: Content inside HTML comment blocks was generated by mdat and may be overwritten. +-->

<!-- title -->

# vite-plugin-iife

<!-- /title -->

<!-- badges -->

[![NPM Package vite-plugin-iife](https://img.shields.io/npm/v/vite-plugin-iife.svg)](https://npmjs.com/package/vite-plugin-iife)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

<!-- /badges -->

<!-- short-description -->

**Vite plugin for simple IIFE-compiled script imports.**

<!-- /short-description -->

## Overview

Sometimes you need a small snippet of code to run in a specific place at at a specific time during a page's loading process to achieve a specific effect or prevent the dreaded [FOUC](https://en.wikipedia.org/wiki/Flash_of_unstyled_content).

Running scripts as modules is great, but [by design they are unavoidably executed](https://jakearchibald.com/2017/es-modules-in-browsers/#defer-by-default) with an implicit `defer`, and build systems can make it tricky to get a single chunk of code to behave differently.

This plugin lets you write scripts to be inlined using either JavaScript or TypeScript, and get a minified JavaScript [`IIFE`](https://developer.mozilla.org/en-US/docs/Glossary/IIFE) snippet of code via an `import` statement, which makes it easy to integrate with static site generators:

```ts
import inlineIifeSnippet from './some-script.ts?iife'

// Logs the raw IIFE-compiled code from some-script.ts:
console.log(inlineIifeSnippet)
```

## Installation

### 1. Install the plugin package

Assuming you're starting with a Vite project of some flavor:

```sh
npm install --save-dev vite-plugin-iife
```

### 2. Add the plugin to your `vite.config` file

```ts
// vite.config.ts
import iife from 'vite-plugin-iife'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [iife()],
})
```

### 3. Configure TypeScript

_Skip this step if you're using plain JavaScript._

Add the extension declarations to your [types](https://www.typescriptlang.org/tsconfig#types) in tsconfig.json:

```json
{
  "compilerOptions": {
    "types": ["vite-plugin-iife/ext"]
  }
}
```

Alternately, you can add a triple-slash package dependency directive to your global types file (e.g. `env.d.ts` or similar):

```ts
/// <reference types="vite-plugin-iife/ext" />
```

This step should take care of errors like:

```sh
Cannot find module './test-script.ts?iife' or its corresponding type declarations.ts(2307)
```

## Usage

### IIFE imports

Append `?iife` to any script import string to receive the IIFE-compiled code as a default export string:

```ts
// Imported as an IIFE-compiled string
// Embed it in a <script> tag somewhere, etc.
import iifeSnippet from './some-script.ts?iife'

// Imported normally
import snippet from './some-script.ts'
```

Since there's no code splitting or externalization of dependencies, `vite-plugin-iife` is only recommended for small and relatively self-contained scripts. The `verbose` option can help you keep tabs on the output size during development.

### Plugin options

The plugin accepts a few options in its initialization function in your `vite.config` file. The options object type is exported as `IifePluginOptions`.

| Key       | Type                      | Description                                                         | Default |
| --------- | ------------------------- | ------------------------------------------------------------------- | ------- |
| `minify`  | `true \| false \| 'auto'` | Minify output. The 'auto' value only minifies on production builds. | 'auto'  |
| `verbose` | `boolean`                 | Log information to the console.                                     | `false` |

## Maintainers

[@kitschpatrol](https://github.com/kitschpatrol)

<!-- contributing -->

## Contributing

[Issues](https://github.com/kitschpatrol/vite-plugin-iife/issues) and pull requests are welcome.

<!-- /contributing -->

<!-- license -->

## License

[MIT](license.txt) Â© Eric Mika

<!-- /license -->
